Iterator: a pointer-like object that can be incremented with ++, dereferenced with *, and compared against another iterator with !=.
Iterators are generated by STL container member functions, such as begin() and end(). Some containers return iterators that support only the above operations, while others return iterators that can move forward and backward, be compared with <, and so on.

/*     copy(v.begin(), v.end(), l.begin());

an iterator pointing to the first location to copy from
an iterator pointing one element past to the last location to copy from
an iterator pointing to the first location to copy into

In this case, v and l are some STL containers and begin() and end() are member functions that return iterators pointing to locations within those containers.


Note 1: begin() returns a location you can dereference. end() does not. Dereferencing the end pointer is an error. The end pointer is only to be used to see when you've reached it.

Note 2: copy() assumes that the destination already has room for the elements being copied. It would be an error to copy into an empty list or vector. However, this limitation is easily overcome with insert operators.

Iterator Classes
Iterators are divided into classes. These are not real C++ classes, but simply categories of kind of iterators. Each category specifies the operations the iterator supports. For example, some iterators support incrementing but not decrementing, some support dereferencing for getting data but not for storing data, some support scalar arithmetic, i.e., adding n, and some don't. Each STL container defines what class of iterators it can return. Each algorithm specifies what class of iterators it requires. The more powerful iterator classes are usually subclasses of the weaker ones, so if an algorithm requires a minimal iterator, it will work just fine with an iterator with more power.


ITERATORS
begin(),end(),rbegin(),rend(),cbegin(),cend(),crbegin(),crend();
#include<iostream>
#include<vector>

using namespace std;
int main(){
  vector<int> a={1,2,1,3,4,5,6,25,3,6};
  vector<int>::const_reverse_iterator itr;
  for(itr=a.crbegin();itr!=a.crend();itr++){
            cout<<*itr<<' ';
            }
  
  cout<<endl;
  for(auto it=a.crbegin();it!=a.crend();it++){
            
            cout<<*it<<' ';
            
            }
return 0;}


/*size(),max_size(),resize(),capacity(),shrink_to_fit(),empty(),reserve()*/

/*
resize()
vectorname.resize(int n, int val)
Parameters:

n – it is new container size, expressed in number of elements.
val – if this parameter is specified then new elements are initialized with this value.
Return value:

This function do not returns anything.
Exception:

The only exception if it so happens is Bad_alloc thrown, if reallocation fails

*/

/*
std::vector class provides a useful function reserve which helps use specify the minimum size of the vector.It indicates that the vector is created such that it can store at least the number of the specified elements without having to reallocate memory.

std::vector::reserve

void reserve(size_type n)
Return Type: none
Arguments: n which denotes the no of elements to be stored in vector

Requests that vector is large enough to store n elements in the least. 
If the current vector capacity is less than n, then reallocation will 
take place. In other cases, reallocation will not happen. Function does
not modify existing elements in the vector
*/


#include<iostream>
#include<vector>

using namespace std;
int main(){

  vector<int> a={1,2,1,3,4,5,6,25,3,6};
  
  vector<int>::iterator it;
  cout<<a.size()<<endl;/*existing no of elements in the vector*/
  cout<<a.capacity()<<endl;/*no of elements that can be accomodated in the vector*/
  cout<<a.max_size()<<endl;
  cout<<a.empty()<<endl;
  it=a.begin();
  a.erase(it,it+4);
  
  cout<<a.size()<<endl;
  cout<<a.capacity()<<endl;
  cout<<a.max_size()<<endl;
  
  //a.shrink_to_fit();  /*shrinks the capacity of the array to fit the no of elements*/
  a.resize(10,4);
  cout<<a.capacity()<<endl;
  for(it=a.begin();it!=a.end();it++){
          cout<<*it<<' ';}
          cout<<endl;
 
  a.resize(5,4);  
    for(it=a.begin();it!=a.end();it++){
          cout<<*it<<' ';}
          cout<<endl;

  a.reserve(20);
  cout<<a.size()<<endl;
  cout<<a.capacity()<<endl;
    

return 0;}

/*reference_operator[g],at(g),front(),back(),data()*/

/* reference_operator[g]
--- = assigns elements of one container to another container
--- [] gives element at position at the specified location, same thing as at(g) except for the fact that at(g) will throw out of range exception while [] will show undefined behaviour
*/

#include<iostream>
#include<vector>

using namespace std;
int main(){
  vector<int> a={1,2,1,3,4,5,6,25,3,6};
            
  
 vector<int >b;
 b=a;
 for(int i=0;i<b.size();i++){
      cout<<b[i]<<' ';}
      cout<<endl;
      
 b[4]=10;
 for(int i=0;i<b.size();i++){
      cout<<b[i]<<' ';}
      cout<<endl;
 
  
  
return 0;}



















*/
